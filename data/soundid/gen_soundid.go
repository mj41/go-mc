//go:build generate

// gen_soundid.go generates the enumeration of sound IDs.
package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"sort"
	"text/template"
)

const (
	version = "1.21.11"
	infoURL = "https://raw.githubusercontent.com/PrismarineJS/minecraft-data/master/data/pc/" + version + "/sounds.json"
	// language=gohtml
	soundTmpl = `// Code generated by gen_soundid.go. DO NOT EDIT.

package soundid

// SoundID represents a sound ID used in the minecraft protocol.
type SoundID int32

// SoundNames - map of ids to names for sounds.
var SoundNames = map[SoundID]string{ {{range .}}
	{{.ID}}: "{{.Name}}",{{end}}
}

// GetSoundNameByID helper method
func GetSoundNameByID(id SoundID) (string, bool) {
	name, ok := SoundNames[id]
	return name, ok
}`
)

type Sound struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
}

//go:generate go run $GOFILE
//go:generate go fmt soundid.go
func main() {
	fmt.Println("generating soundid.go")
	sounds, err := downloadSoundInfo()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	f, err := os.Create("soundid.go")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	if err := template.Must(template.New("").Parse(soundTmpl)).Execute(f, sounds); err != nil {
		panic(err)
	}
}

func downloadSoundInfo() ([]*Sound, error) {
	var data []*Sound

	// Support local data directory via env var (for versions not yet on PrismarineJS master).
	if dir := os.Getenv("MINECRAFT_DATA_DIR"); dir != "" {
		raw, err := os.ReadFile(filepath.Join(dir, "sounds.json"))
		if err != nil {
			return nil, err
		}
		if err := json.Unmarshal(raw, &data); err != nil {
			return nil, err
		}
	} else {
		resp, err := http.Get(infoURL)
		if err != nil {
			return nil, err
		}
		defer resp.Body.Close()
		if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
			return nil, err
		}
	}

	sort.SliceStable(data, func(i, j int) bool {
		return data[i].ID < data[j].ID
	})

	return data, nil
}
