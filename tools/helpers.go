package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"unicode"
)

// jsonVersion is the MC version directory name extracted from jsonDir
// (e.g. "1.21.11"). Set in main() before generators run.
var jsonVersion string

// generatedHeader returns a "Code generated by" comment line.
// generatorFile is the source file (e.g. "gen_registryid.go").
// sourceFiles are the input JSON filenames (e.g. "registries.json").
func generatedHeader(generatorFile string, sourceFiles ...string) string {
	var src string
	if len(sourceFiles) > 0 {
		var parts []string
		for _, f := range sourceFiles {
			parts = append(parts, jsonVersion+"/"+f)
		}
		src = " from " + strings.Join(parts, " + ")
	}
	return fmt.Sprintf("// Code generated by tools/%s%s; DO NOT EDIT.\n", generatorFile, src)
}

// ---------------------------------------------------------------------------
// Shared JSON types
// ---------------------------------------------------------------------------

// registriesJSON is the top-level structure of registries.json.
// Used by gen_soundid, gen_item, and gen_registryid.
type registriesJSON map[string]registryData

type registryData struct {
	Default    string                       `json:"default"`
	Entries    map[string]registryEntryData `json:"entries"`
	ProtocolID int                          `json:"protocol_id"`
}

type registryEntryData struct {
	ProtocolID int `json:"protocol_id"`
}

// ---------------------------------------------------------------------------
// I/O helpers
// ---------------------------------------------------------------------------

// readJSON reads a JSON file and unmarshals it into v.
func readJSON(path string, v any) error {
	data, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("reading %s: %w", path, err)
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("parsing %s: %w", path, err)
	}
	return nil
}

// writeFile writes data to path, creating parent directories as needed.
func writeFile(path string, data []byte) error {
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return fmt.Errorf("creating directory for %s: %w", path, err)
	}
	if err := os.WriteFile(path, data, 0o644); err != nil {
		return fmt.Errorf("writing %s: %w", path, err)
	}
	return nil
}

// logf prints a message to stderr.
func logf(format string, args ...any) {
	fmt.Fprintf(os.Stderr, format+"\n", args...)
}

// ---------------------------------------------------------------------------
// String helpers
// ---------------------------------------------------------------------------

// snakeToCamel converts "grass_block" to "GrassBlock".
func snakeToCamel(s string) string {
	parts := strings.Split(s, "_")
	var b strings.Builder
	for _, p := range parts {
		if p == "" {
			continue
		}
		runes := []rune(p)
		runes[0] = unicode.ToUpper(runes[0])
		b.WriteString(string(runes))
	}
	return b.String()
}

// snakeToTitle converts "polished_granite" to "Polished Granite".
func snakeToTitle(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		if p == "" {
			continue
		}
		runes := []rune(p)
		runes[0] = unicode.ToUpper(runes[0])
		parts[i] = string(runes)
	}
	return strings.Join(parts, " ")
}

// stripMinecraftPrefix removes the "minecraft:" prefix from a name.
func stripMinecraftPrefix(name string) string {
	if i := strings.Index(name, ":"); i >= 0 {
		return name[i+1:]
	}
	return name
}

// ---------------------------------------------------------------------------
// Flag helpers (lightweight, no flag package needed)
// ---------------------------------------------------------------------------

// flagValue returns the value of --key from args, or "" if not found.
func flagValue(args []string, key string) string {
	for i, a := range args {
		if a == key && i+1 < len(args) {
			return args[i+1]
		}
	}
	return ""
}

// flagBool returns true if --key appears in args.
func flagBool(args []string, key string) bool {
	for _, a := range args {
		if a == key {
			return true
		}
	}
	return false
}

// ---------------------------------------------------------------------------
// Size formatting
// ---------------------------------------------------------------------------

// humanSize formats a byte count as a human-readable string.
func humanSize(b int64) string {
	const unit = 1024
	if b < unit {
		return fmt.Sprintf("%d B", b)
	}
	div, exp := int64(unit), 0
	for n := b / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(b)/float64(div), "KMG"[exp])
}
