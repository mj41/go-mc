// gen_component_types generates individual _gen.go files for each component type
// defined in hand-crafted/component_schema.json.
package main

import (
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

// componentSchema represents one entry in hand-crafted/component_schema.json.
type componentSchema struct {
	Name      string       `json:"name"`
	Pattern   string       `json:"pattern"`
	EmbedType string       `json:"embedType,omitempty"`
	FieldName string       `json:"fieldName,omitempty"`
	FieldType string       `json:"fieldType,omitempty"`
	SerMethod string       `json:"serMethod,omitempty"`
	BaseType  string       `json:"baseType,omitempty"`
	ElemType  string       `json:"elementType,omitempty"`
	Fields    []tupleField `json:"fields,omitempty"`
}

type tupleField struct {
	Name string `json:"name"`
	Type string `json:"type"`
}

func genComponentTypes(goMCRoot string) error {
	schemaPath := filepath.Join(goMCRoot, "tools", "hand-crafted", "component_schema.json")
	compDir := filepath.Join(goMCRoot, "level", "component")

	var schema []componentSchema
	if err := readJSON(schemaPath, &schema); err != nil {
		return fmt.Errorf("genComponentTypes: %w", err)
	}

	generatedTypes := make(map[string]bool)
	generated := 0
	for _, s := range schema {
		if s.Pattern == "custom" || s.Pattern == "named_int" {
			continue
		}
		goName := componentGoName(s.Name)
		code, err := generateComponentCode(s, goName)
		if err != nil {
			return fmt.Errorf("genComponentTypes: %s: %w", s.Name, err)
		}

		formatted, err := format.Source([]byte(code))
		if err != nil {
			return fmt.Errorf("genComponentTypes: %s: gofmt: %w\n---\n%s", s.Name, err, code)
		}

		fileName := strings.ToLower(goName) + "_gen.go"
		outPath := filepath.Join(compDir, fileName)
		if err := writeFile(outPath, formatted); err != nil {
			return fmt.Errorf("genComponentTypes: %w", err)
		}
		generatedTypes[goName] = true
		generated++
	}

	logf("genComponentTypes: generated %d component type files in %s", generated, compDir)
	logReplaceableFiles(compDir, generatedTypes)
	return nil
}

func generateComponentCode(s componentSchema, goName string) (string, error) {
	switch s.Pattern {
	case "embed":
		return genEmbed(s, goName), nil
	case "embed_nbt":
		return genEmbedNBT(s, goName), nil
	case "eitherholder":
		return genEitherHolder(s, goName), nil
	case "empty":
		return genEmpty(s, goName), nil
	case "delegate":
		return genDelegate(s, goName), nil
	case "array":
		return genArray(s, goName), nil
	case "tuple":
		return genTuple(s, goName), nil
	default:
		return "", fmt.Errorf("unknown pattern %q", s.Pattern)
	}
}

const compGenHeader = "// Code generated by tools/gen_component_types.go from hand-crafted/component_schema.json; DO NOT EDIT.\n"

// compReceiver returns a lowercase receiver variable for the given Go type name,
// avoiding collision with 'r' (reader) and 'w' (writer) params.
func compReceiver(goName string) string {
	ch := strings.ToLower(goName[:1])
	if ch == "r" || ch == "w" {
		if len(goName) > 1 {
			ch2 := strings.ToLower(goName[1:2])
			if ch2 != "r" && ch2 != "w" {
				return ch2
			}
		}
		return "x"
	}
	return ch
}

// ---------------------------------------------------------------------------
// Import set
// ---------------------------------------------------------------------------

type importSet struct {
	entries map[string]string // path → alias ("" for no alias)
}

func newImportSet() *importSet {
	return &importSet{entries: make(map[string]string)}
}

func (is *importSet) addIO()    { is.entries["io"] = "" }
func (is *importSet) addPk()    { is.entries["github.com/Tnze/go-mc/net/packet"] = "pk" }
func (is *importSet) addDynbt() { is.entries["github.com/Tnze/go-mc/nbt/dynbt"] = "" }
func (is *importSet) addChat()  { is.entries["github.com/Tnze/go-mc/chat"] = "" }
func (is *importSet) addBlock() { is.entries["github.com/Tnze/go-mc/level/block"] = "" }

// addForType adds imports required for a given type string.
func (is *importSet) addForType(typ string) {
	if strings.Contains(typ, "pk.") {
		is.addPk()
	}
	if strings.Contains(typ, "chat.") {
		is.addChat()
	}
	if strings.Contains(typ, "dynbt.") {
		is.addDynbt()
	}
	if strings.Contains(typ, "block.") {
		is.addBlock()
	}
}

func (is *importSet) render() string {
	if len(is.entries) == 0 {
		return ""
	}

	type imp struct {
		path, alias string
	}
	var stdlib, external []imp
	for path, alias := range is.entries {
		if isStdlibImport(path) {
			stdlib = append(stdlib, imp{path, alias})
		} else {
			external = append(external, imp{path, alias})
		}
	}
	sort.Slice(stdlib, func(i, j int) bool { return stdlib[i].path < stdlib[j].path })
	sort.Slice(external, func(i, j int) bool { return external[i].path < external[j].path })

	var buf strings.Builder
	buf.WriteString("import (\n")
	for _, im := range stdlib {
		if im.alias != "" {
			fmt.Fprintf(&buf, "\t%s %q\n", im.alias, im.path)
		} else {
			fmt.Fprintf(&buf, "\t%q\n", im.path)
		}
	}
	if len(stdlib) > 0 && len(external) > 0 {
		buf.WriteString("\n")
	}
	for _, im := range external {
		if im.alias != "" {
			fmt.Fprintf(&buf, "\t%s %q\n", im.alias, im.path)
		} else {
			fmt.Fprintf(&buf, "\t%q\n", im.path)
		}
	}
	buf.WriteString(")\n")
	return buf.String()
}

func isStdlibImport(path string) bool {
	return !strings.Contains(path, ".")
}

// ---------------------------------------------------------------------------
// Pattern generators
// ---------------------------------------------------------------------------

func genEmbed(s componentSchema, goName string) string {
	is := newImportSet()
	is.addForType(s.EmbedType)

	var buf strings.Builder
	buf.WriteString(compGenHeader)
	buf.WriteString("package component\n\n")
	if imports := is.render(); imports != "" {
		buf.WriteString(imports)
		buf.WriteString("\n")
	}
	fmt.Fprintf(&buf, "var _ DataComponent = (*%s)(nil)\n\n", goName)
	fmt.Fprintf(&buf, "type %s struct{ %s }\n\n", goName, s.EmbedType)
	fmt.Fprintf(&buf, "func (%s) ID() string { return %q }\n", goName, s.Name)
	return buf.String()
}

func genEmbedNBT(s componentSchema, goName string) string {
	is := newImportSet()
	is.addIO()
	is.addDynbt()
	is.addPk()

	rcv := compReceiver(goName)

	var buf strings.Builder
	buf.WriteString(compGenHeader)
	buf.WriteString("package component\n\n")
	buf.WriteString(is.render())
	buf.WriteString("\n")
	fmt.Fprintf(&buf, "var _ DataComponent = (*%s)(nil)\n\n", goName)
	fmt.Fprintf(&buf, "type %s struct{ dynbt.Value }\n\n", goName)
	fmt.Fprintf(&buf, "func (%s) ID() string { return %q }\n\n", goName, s.Name)
	fmt.Fprintf(&buf, "func (%s *%s) ReadFrom(r io.Reader) (int64, error) {\n", rcv, goName)
	fmt.Fprintf(&buf, "\treturn pk.NBT(&%s.Value).ReadFrom(r)\n", rcv)
	buf.WriteString("}\n\n")
	fmt.Fprintf(&buf, "func (%s *%s) WriteTo(w io.Writer) (int64, error) {\n", rcv, goName)
	fmt.Fprintf(&buf, "\treturn pk.NBT(&%s.Value).WriteTo(w)\n", rcv)
	buf.WriteString("}\n")
	return buf.String()
}

func genEitherHolder(s componentSchema, goName string) string {
	var buf strings.Builder
	buf.WriteString(compGenHeader)
	buf.WriteString("package component\n\n")
	fmt.Fprintf(&buf, "var _ DataComponent = (*%s)(nil)\n\n", goName)
	fmt.Fprintf(&buf, "type %s struct{ EitherHolder }\n\n", goName)
	fmt.Fprintf(&buf, "func (%s) ID() string { return %q }\n", goName, s.Name)
	return buf.String()
}

func genEmpty(s componentSchema, goName string) string {
	is := newImportSet()
	is.addIO()

	rcv := compReceiver(goName)

	var buf strings.Builder
	buf.WriteString(compGenHeader)
	buf.WriteString("package component\n\n")
	buf.WriteString(is.render())
	buf.WriteString("\n")
	fmt.Fprintf(&buf, "var _ DataComponent = (*%s)(nil)\n\n", goName)
	fmt.Fprintf(&buf, "type %s struct{}\n\n", goName)
	fmt.Fprintf(&buf, "func (%s) ID() string { return %q }\n\n", goName, s.Name)
	fmt.Fprintf(&buf, "func (%s *%s) ReadFrom(r io.Reader) (int64, error) { return 0, nil }\n\n", rcv, goName)
	fmt.Fprintf(&buf, "func (%s *%s) WriteTo(w io.Writer) (int64, error) { return 0, nil }\n", rcv, goName)
	return buf.String()
}

func genDelegate(s componentSchema, goName string) string {
	is := newImportSet()
	is.addIO()
	is.addForType(s.FieldType)

	if s.SerMethod == "nbt" || s.SerMethod == "nbtfield" {
		is.addPk()
	}

	rcv := compReceiver(goName)

	var readExpr, writeExpr string
	switch s.SerMethod {
	case "direct":
		readExpr = fmt.Sprintf("%s.%s.ReadFrom(r)", rcv, s.FieldName)
		writeExpr = fmt.Sprintf("%s.%s.WriteTo(w)", rcv, s.FieldName)
	case "nbt":
		readExpr = fmt.Sprintf("pk.NBT(&%s.%s).ReadFrom(r)", rcv, s.FieldName)
		writeExpr = fmt.Sprintf("pk.NBT(&%s.%s).WriteTo(w)", rcv, s.FieldName)
	case "nbtfield":
		readExpr = fmt.Sprintf("pk.NBTField{V: &%s.%s, AllowUnknownFields: true}.ReadFrom(r)", rcv, s.FieldName)
		writeExpr = fmt.Sprintf("pk.NBTField{V: &%s.%s, AllowUnknownFields: true}.WriteTo(w)", rcv, s.FieldName)
	}

	var buf strings.Builder
	buf.WriteString(compGenHeader)
	buf.WriteString("package component\n\n")
	buf.WriteString(is.render())
	buf.WriteString("\n")
	fmt.Fprintf(&buf, "var _ DataComponent = (*%s)(nil)\n\n", goName)
	fmt.Fprintf(&buf, "type %s struct {\n\t%s %s\n}\n\n", goName, s.FieldName, s.FieldType)
	fmt.Fprintf(&buf, "func (%s) ID() string { return %q }\n\n", goName, s.Name)
	fmt.Fprintf(&buf, "func (%s *%s) ReadFrom(r io.Reader) (int64, error) {\n", rcv, goName)
	fmt.Fprintf(&buf, "\treturn %s\n", readExpr)
	buf.WriteString("}\n\n")
	fmt.Fprintf(&buf, "func (%s *%s) WriteTo(w io.Writer) (int64, error) {\n", rcv, goName)
	fmt.Fprintf(&buf, "\treturn %s\n", writeExpr)
	buf.WriteString("}\n")
	return buf.String()
}

func genArray(s componentSchema, goName string) string {
	is := newImportSet()
	is.addIO()
	is.addPk()
	is.addForType(s.ElemType)

	rcv := compReceiver(goName)

	var buf strings.Builder
	buf.WriteString(compGenHeader)
	buf.WriteString("package component\n\n")
	buf.WriteString(is.render())
	buf.WriteString("\n")
	fmt.Fprintf(&buf, "var _ DataComponent = (*%s)(nil)\n\n", goName)
	fmt.Fprintf(&buf, "type %s struct {\n\t%s []%s\n}\n\n", goName, s.FieldName, s.ElemType)
	fmt.Fprintf(&buf, "func (%s) ID() string { return %q }\n\n", goName, s.Name)
	fmt.Fprintf(&buf, "func (%s *%s) ReadFrom(r io.Reader) (int64, error) {\n", rcv, goName)
	fmt.Fprintf(&buf, "\treturn pk.Array(&%s.%s).ReadFrom(r)\n", rcv, s.FieldName)
	buf.WriteString("}\n\n")
	fmt.Fprintf(&buf, "func (%s *%s) WriteTo(w io.Writer) (int64, error) {\n", rcv, goName)
	fmt.Fprintf(&buf, "\treturn pk.Array(&%s.%s).WriteTo(w)\n", rcv, s.FieldName)
	buf.WriteString("}\n")
	return buf.String()
}

func genTuple(s componentSchema, goName string) string {
	is := newImportSet()
	is.addIO()
	is.addPk()

	rcv := compReceiver(goName)

	for _, f := range s.Fields {
		is.addForType(f.Type)
		if inner := extractInnerType(f.Type); inner != "" {
			is.addForType(inner)
		}
	}

	var buf strings.Builder
	buf.WriteString(compGenHeader)
	buf.WriteString("package component\n\n")
	buf.WriteString(is.render())
	buf.WriteString("\n")
	fmt.Fprintf(&buf, "var _ DataComponent = (*%s)(nil)\n\n", goName)

	// Struct definition.
	fmt.Fprintf(&buf, "type %s struct {\n", goName)
	for _, f := range s.Fields {
		fmt.Fprintf(&buf, "\t%s %s\n", f.Name, fieldStructType(f.Type))
	}
	buf.WriteString("}\n\n")

	// ID.
	fmt.Fprintf(&buf, "func (%s) ID() string { return %q }\n\n", goName, s.Name)

	// ReadFrom.
	fmt.Fprintf(&buf, "func (%s *%s) ReadFrom(r io.Reader) (int64, error) {\n", rcv, goName)
	buf.WriteString("\treturn pk.Tuple{\n")
	for _, f := range s.Fields {
		fmt.Fprintf(&buf, "\t\t%s,\n", fieldTupleArg(rcv, f))
	}
	buf.WriteString("\t}.ReadFrom(r)\n")
	buf.WriteString("}\n\n")

	// WriteTo.
	fmt.Fprintf(&buf, "func (%s *%s) WriteTo(w io.Writer) (int64, error) {\n", rcv, goName)
	buf.WriteString("\treturn pk.Tuple{\n")
	for _, f := range s.Fields {
		fmt.Fprintf(&buf, "\t\t%s,\n", fieldTupleArg(rcv, f))
	}
	buf.WriteString("\t}.WriteTo(w)\n")
	buf.WriteString("}\n")
	return buf.String()
}

// ---------------------------------------------------------------------------
// Type helpers
// ---------------------------------------------------------------------------

// extractInnerType extracts the inner type from pk.Array[T], pk.Option[T], pk.NBTField[T].
func extractInnerType(typ string) string {
	for _, prefix := range []string{"pk.Array[", "pk.Option[", "pk.NBTField["} {
		if strings.HasPrefix(typ, prefix) && strings.HasSuffix(typ, "]") {
			return typ[len(prefix) : len(typ)-1]
		}
	}
	return ""
}

// fieldStructType converts a schema type to a Go struct field type.
//
//	pk.Array[T]    → []T
//	pk.Option[T]   → pk.Option[T, *T]
//	pk.NBTField[T] → T
//	everything else → as-is
func fieldStructType(typ string) string {
	if strings.HasPrefix(typ, "pk.Array[") && strings.HasSuffix(typ, "]") {
		inner := typ[len("pk.Array[") : len(typ)-1]
		return "[]" + inner
	}
	if strings.HasPrefix(typ, "pk.Option[") && strings.HasSuffix(typ, "]") {
		inner := typ[len("pk.Option[") : len(typ)-1]
		return fmt.Sprintf("pk.Option[%s, *%s]", inner, inner)
	}
	if strings.HasPrefix(typ, "pk.NBTField[") && strings.HasSuffix(typ, "]") {
		inner := typ[len("pk.NBTField[") : len(typ)-1]
		return inner
	}
	return typ
}

// fieldTupleArg returns the expression used in pk.Tuple{...} for a field.
//
//	pk.Array[T]    → pk.Array(&rcv.Name)
//	pk.Option[T]   → &rcv.Name
//	pk.NBTField[T] → pk.NBTField{V: &rcv.Name, AllowUnknownFields: true}
//	everything else → &rcv.Name
func fieldTupleArg(rcv string, f tupleField) string {
	if strings.HasPrefix(f.Type, "pk.Array[") {
		return fmt.Sprintf("pk.Array(&%s.%s)", rcv, f.Name)
	}
	if strings.HasPrefix(f.Type, "pk.NBTField[") {
		return fmt.Sprintf("pk.NBTField{V: &%s.%s, AllowUnknownFields: true}", rcv, f.Name)
	}
	return fmt.Sprintf("&%s.%s", rcv, f.Name)
}

// ---------------------------------------------------------------------------
// Replaceable file logging
// ---------------------------------------------------------------------------

// logReplaceableFiles scans existing (non-generated) .go files in compDir for
// struct type definitions that match generated types, and logs them so the user
// knows which hand-written files can be deleted.
func logReplaceableFiles(compDir string, generatedTypes map[string]bool) {
	entries, err := os.ReadDir(compDir)
	if err != nil {
		return
	}
	re := regexp.MustCompile(`^type\s+(\w+)\s+struct`)
	var replaceable []string
	for _, e := range entries {
		if e.IsDir() || !strings.HasSuffix(e.Name(), ".go") {
			continue
		}
		if strings.HasSuffix(e.Name(), "_gen.go") || e.Name() == "components.go" {
			continue
		}
		data, err := os.ReadFile(filepath.Join(compDir, e.Name()))
		if err != nil {
			continue
		}
		matches := re.FindAllSubmatch(data, -1)
		var found []string
		for _, m := range matches {
			name := string(m[1])
			if generatedTypes[name] {
				found = append(found, name)
			}
		}
		if len(found) > 0 {
			replaceable = append(replaceable, fmt.Sprintf("  %s (types: %s)", e.Name(), strings.Join(found, ", ")))
		}
	}
	if len(replaceable) > 0 {
		logf("genComponentTypes: hand-written files replaceable by _gen.go:")
		for _, r := range replaceable {
			logf("%s", r)
		}
	}
}
